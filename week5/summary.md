# 第7章  排序

讨论数组排序元素的排序问题

数组中只包含整数

排序工作在主存中完成，元素的个数相对来说较少

不在主存完成而必须在外存完成的排序称为外部排序

## 7.1  预备知识

每个算法都将接收一个含有元素的数组和一个包含元素个数的整数

基于比较的元素

## 7.2  插入排序

#### 7.2.1  算法

插入排序由N-1趟排序组成

对于P=1趟到P=N-1趟，插入排序保证从位置0到位置P上的元素为已排序状态

在第P趟，我们将位置P上的元素向左移动到它在前P+1个元素中的正确位置

#### 7.2.2  插入排序的分析

由于嵌套循环每趟花费N次迭代，因此插入排序为O(N方)

## 7.3  一些简单排序算法的下界

数字数组的一个逆序（inversion）是指数组中具有i<j但A[I]>A[j]的序偶（A[i],A[j]）

序偶的个数正好是需要由插入排序（非直接）执行的交换次数

 由于算法中还有O（N）项其他工作，因此插入排序的运行时间是O（I+N）,其中I为原始数组中的逆序数 

若逆序数是O（N），则插入排序以线性时间运行

/*定理7.1 N个互异数的数组的平均逆序数是N(N-1)/4*/

/*定理7.2  通过交换相邻元素进行排序的任何算法平均需要O（N方）时间*/

## 7.4  希尔排序

希尔排序有时也叫做缩小增量排序

## 7.5  堆排序

优先队列可以用于花费O(N log N)时间的排序，基于该想法的算法叫做堆排序（heapsort）

##### 堆序性分析

第一阶段构建堆最多用到2N次比较

第二阶段，第i次DeleteMax最多用到2[log i]次比较，总数最多为2N logN-O(N)次比较

连续的DeleteMax操作破坏了堆的随机性，使得概率论证非常复杂

/*定理7.5 对N个互异项的随机排列进行堆排序，所用的平均次数为

2N log N-O（N log log N）*/

## 7.6  归并排序

归并排序以O(N log N)最坏情形运行时间运行，而所使用的比较次数几乎是最优的。

合并两个已排序的表，该算法可以通过对输入数据一趟排序来完成

基本合并算法是取两个输入数组A、B，一个输出数组C，以及三个计数器（Ptr）

合并两个已排序的表的时间显然是线性的

称为归并排序（Mergesort）的过程是递归例程Msort的一个驱动程序

由于Merge位于MSort的最后一行，因此在任意时刻只需要一个临时数组活动，而且可以使用该临时数组的任意部分

## 7.7  快速排序

1、如果S中元素个数是0或者1，则返回

2、取S中任意元素v，称之为枢纽元

3、将S-v分成两个不相交的集合：S1中x小于v，S2中x大于v

4、返回S1后继而v继而S2

一个好的实现方法尽量使得v为中间数

快速排序更快的原因在于第三步的分割实际上是在适当的位置上进行且非常有效，它的高效大大弥补了大小不等的递归调用的缺憾

#### 7.7.1  选取枢纽元

##### 一个错误的方法

将第一个元素用作枢纽元，因为往往输入是预排序的

或

选取前两个互异关键字中较大者作为枢纽元

##### 一种安全的做法（昂贵）

生成随机数做v

但随机数的生成是昂贵的，根本减少不了算法其余部分的平均运行时间

##### 三数中值分割法

任选三个元素并用它们的中值作为枢纽元

随机性没有多大的帮助，一般使用左端、右端、中心位置上的三个元素作为枢纽元

#### 7.7.2  分割策略

第一步通过将枢纽元与最后的元素交换使得枢纽元离开要被分割的数据段

i从第一个元素开始，j从倒数第二个元素开始

分割阶段把所有小元素移到数组的左边而把大的元素移到数组的右边

当然，小和大是相对于枢纽而言

#### 7.7.3  小数组

对于很小的数组（N小于等于20），快速排序不如插入排序好

#### 7.7.4  实际的快速排序例程

#### 7.7.5  快速排序的分析

正如归并排序那样，快速排序也是递归的

##### 最坏情形的分析

枢纽始终是最小元素T（N）=O（N方）

##### 最好情形的分析

枢纽正好位于中间

T(N)=O(N log N)

这和归并排序的分析完全相同，因此我们得到同样的答案

##### 平均情形的分析

任何大小都有可能

T（N）=O(N log N)

#### 7.7.6  选择的线性期望时间算法

## 7.8  大型结构的排序

对于大型结构交换两个结构十分昂贵，实际解法是让输入数组包含指向结构的指针，并在必要时交换指针来进行排序

这意味着，所有数据运动基本上就像我们对整数排序那样进行，我们称之为间接排序

## 7.9  排序的一般下届

##### 决策树

## 7.10  桶式结构

## 7.11  外部排序

迄今为止，我们考察过的所有算法都需要将输入数据装入内存，但存在一些应用程序因输入数据量太大而无法装入内存

#### 7.11.1  为什么需要新的算法

因为旧的算法存在不可忽视的效率损失

#### 7.11.2  外部排序模型

外部排序比内部排序对设备依赖严重得多

我们需要两个驱动器执行有效排序，第三个驱动器进行简化工作

#### 7.11.3  简单算法

第一步从输入磁带一次读入M个记录，在内部将这些写记录排序，然后交替地写到Tb1或Tb2上

我们把每组排过序的记录叫做顺串（run）

然后我们将每个磁带的第一个顺串取出二者合并，把结果写在Ta1上；进行同样的步骤，将结果写在Ta2上。

继续这个过程直至Tb1或Tb2为空

#### 7.11.4  多路合并

如果有额外的磁带可以减少输入数据所需的趟数

唯一区别在于，它发现k个元素中最小元素的过程稍微有些复杂，我们可以用优先队列来寻找，写出一个后进行一次DeleteMin操作

#### 7.11.5  多相合并

#### 7.11.6  替换选择





# 第8章  不相交集 ADT

## 8.1  等价关系

对于每一对元素(a,b)，a、b属于S， aRb或者为true或者为false,则称在集合S上定义关系R

如果aRb是true，那么我们说a和b有关系



等价关系是满足下列三个性质的关系R

1、（自反性）对于所有的a属于S，aRa

2、   (对称性)  aRb当且仅当  bRa

3、   (传递性) 若aRb且bRc则aRc

电气连接是一个等价关系

## 8.2  动态等价性关系

一个元素a属于S的等价类是S的子集，它包含所有与a有关系的元素

S的每一个成员恰好出现在一个等价类中。为确定是否a与b等价，我们只需验证a和b是否都在同一个等价类中

1、Find返回等价类的名字

2、添加关系。如果不在同一个类中用Union把含有a和b的两个等价类合并成一个新的等价类

## 8.3  基本数据结构

一种想法是可以使用树来表示每一个集合，因为树上的每一个元素都有相同的根。（树的集合叫做森林）

假设树被非显式地存储在一个数组中：P[i]表示元素i的父亲，若i为父节点则P[i]等于0

为执行Union，我们使一个节点的根指针只想另一棵树的根节点

## 8.4  灵巧求并算法

##### 按大小求并

对上面Union的改进是借助任意的方法打破现有关系，使得总让较小树成为较大树的子树

按大小进行，那么任何节点的深度均不会超过log N，因此它的深度最多可以增加log N

这意味着Find操作的运行时间是O（log N），而连续M次操作 则花费O（M log N）

为了实现这种方法，我们需要记住每一棵树的大小，让数组元素包含它的树的大小的负值

初始时树的数组表示就都是-1，当执行Union时，检查树的大小，新的大小是老的大小的和

##### 按高度求并

保证所有树的深度最多是O（log N），执行Union使得浅的树成为深的树的子树

这是一种平缓的算法，因为只有当两棵相等深度的树求并时树的高度才增加1

## 8.5  路径压缩

执行Union操作的任何算法都将产生相同的最坏情形的树，因为它必然会随意打破树间的平衡

无须对整个数据结构进行加工而使算法加速的唯一方法是对Find操作做些更聪明的工作，即路径压缩

路径压缩在一次Find操作期间执行，而与用来执行Union的方法无关

从X到根的路径上的每一个节点都使它的父亲节点变成根

## 8.6  按秩求并和路径的最坏情形


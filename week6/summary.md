# 第十章  算法设计技巧

## 10.1  贪婪算法

选择局部最优的算法，这种眼下能够拿到的就拿的策略即是这类算法名称的来源

#### 10.1.1  一个简单的调度问题

假设使用非预占调度：一旦开始一个作业就必须把该作业运行完

调度的总代价为C

##### 多处理器情况

处理器个数P能够整除作业数N时存在许多最优的顺序，把jiP+1到j(i+1)P的每一个作业放到不同的处理器上

##### 将最后完成时间最小化

使每一个处理器均没有空闲时间

#### 10.1.2  哈夫曼编码

这一节考虑贪婪算法的第二个应用，成为文件压缩

一般策略是对于不同字符让代码的长度是变化不等的

代表字母的二进制代码可以用二叉树来表示

##### 哈夫曼算法

算法针对一个由树组成的森林。一棵树的权等于它的树叶的频率的和

每棵树的权在根处以小号数字标出，将两棵权最低的树合并到一起

该算法为贪婪算法的点在于每一阶段都立足于当下进行合并，并未进行全局考虑

#### 10.1.3  近似装箱问题

这些算法将运行得很快但未必产生最优解

##### 联机算法

##### 下项适合算法

##### 首次适合算法

##### 最佳适合算法

##### 脱机算法

## 10.2  分治算法

分：递归解决较小的问题

治：从子问题的解构建原问题的解

传统上，在正文中至少含有两个递归调用的例程叫做分治算法，而正文中只含一个递归调用的例程不是分治算法

#### 10.2.1  运行时间

分治算法是把问题分成一些子问题，每个子问题都是原问题的一部分，然后进行某些附加的工作以算出最后的答案

T(N)=2T (N/2)+O(N)

#### 10.2.2  最近点问题

我们要找出一对最近的点，有可能两个点位于相同的位置，在这种情况下这两个点就是最近的，它们的距离为零

详尽搜索花费O(N方)的算法

对于均匀分布的大型点集，预计位于该带中的点的个数是非常少的，平均只有O(根号N)个

改进算法：确定dc两个点的y坐标差别对多是斯格玛

#### 10.2.3  选择问题

要求我们找出含N个元素的表S中的第k个最小的元素

方法1：通过把组元素排序，选择可以容易地以O（N log N）最坏情形时间内解决

方法2：基本算法是简单递归策略选择v做枢纽元

##### 降低比较的平均次数

#### 10.2.4  运算问题的理论改进

##### 整数相乘

##### 矩阵乘法

在N不够大时不如直接相乘，也不能推广到矩阵是稀疏的情况，它只有有限的适用性

## 10.3  动态规划

#### 10.3.1   用一个表代替递归

T(N)是以与斐波那契数相同的增长速度在增长从而是指数增长

如果编译器的递归模拟算法如果能够保留一个预先算出的值的表而对已经解过的子问题不再进行递归调用，那么这种指数式的爆炸增长就可以避免

#### 10.3.2  矩阵乘法的顺序安排

虽然矩阵乘法运算是不可交换的，但是它是可结合的，这就意味着矩阵的乘积ABCD可以以任何顺序添加括号然后再计算其值

最好的排列顺序大约只用了最坏的排列顺序方法的九分之一的乘法次数因此进行一些计算还是很值得的

#### 10.3.3  最优二叉查找树

访问d处的一个元素所需要的比较次数是d+1,因此如果wi被放在深度di上，那么我们就要将pi（1+di）极小化

#### 10.3.4  所有点对最短路径

## 10.4  随机化算法

使用随机枢纽元的快速算法是一个O（N log N)期望时间算法

#### 10.4.1  随机数生成器

使时间用微秒为单位记录

xi+1=Axi mod M

在M—1=10个数 以后，序列将重复。因此，这个序列的周期为M-1，它是尽可能大的

#### 10.4.2  跳跃表

依据随机数n大小，产生具有n个指针的节点，指针分别指向后面的节点。

#### 10.4.3  素性测试、

进行检测一数字是否为素数

## 10.5  回溯算法

回溯算法相当于穷举搜索的巧妙应用，但性能一般不理想，但比蛮力穷举搜索，工作量也是有所改进。

#### 10.5.1  收费公路重建问题

#### 10.5.2  博弈

通过进行仔细的逐个情况的分析,构造一个从不输棋而且当机会出现时总能赢棋的算法。这之所以能够做到是因为一些位置是已知的陷阱，可以通过查表来处理。另外一些方法(如当中央的方格可用时占据该方格）可使分析更简单。

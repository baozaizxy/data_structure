# AA树

AA树是红黑树的一种变形。1.红节点只能作为节点的右孩子，黑节点则都行。2.红节点的level与父节点的level相同。3.黑节点的level比父节点的level小1. 4.左孩子的level比父节点小1，右孩子的level比父节点小0或1。

## 禁止出现的情况

### 出现连续向右的水平方向链，即出现连续两个红节点。

左旋（将中间节点提上，将中间节点的孩子给左节点），中间节点level加1.

### 出现向左的水平方向链

右旋（左节点指向中间节点）。

## 插入操作

### 当插入节点作为其父亲的左孩子

右旋，如果出现连续水平向右的方向链，再左旋。

### 当插入节点作为其父亲的右孩子，且插入节点的父亲和祖父的level相同

左旋，如果出现向左的水平链，再右旋。

### 当插入节点作为其父亲的右孩子，且插入节点的父亲和祖父的level不同

直接插入

## 删除操作

### 后继节点不是叶子

后继节点右孩子的值赋给后继节点，删除后继的右孩子。

### 后继节点是叶子

后继节点的值赋给被删节点，后继节点父亲的level减1，如果出现向左或连续向右的水平链，进行右旋或左旋。删除后继节点。



# 二项队列的摊还分析

## 插入操作

### 没有B0树时

创建单节点树A，花费一个时间单位，多了一棵树。

### 有B0树，没有B1树时

创建单节点树B，然后A-B，花费两个时间单位，树的数量不变。

### 有B0树，又有B1树时

创建单节点树D，然后C-D，然后A-C，花费三个时间单位，少了一棵树。

## 总结

Ci是第i次插入的代价，Ti是第i次插入后的树的棵树。由上面三种情况可以推出花费c个单元时间的一次插入导致多了2-c棵树。有公式Ci+（Ti-Ti-1）=2，可以推到C1+（T1-T0）=2。有结论 \sum_{i=0}^{N} {Ci}<=2N。可以推出插入操作的摊还时间是O（1）。

## 合并操作

设两颗树分别有N1，N2节点和T1，T2棵树，并且二项队列有T1<=logN1,T2<=logN2。合并时N=N1+N2，合并之后，最多也只能存在logN棵树。因此合并的摊还时间是O（logN）。

## DeleteMin操作

设一棵树有N个节点和T棵树，删除去一个最小值，设Bi的根是最小值，删除时会多出i棵树，节点变成2^i-1个，再进行合并操作，树木的数量也一定会小于log（N-1）。所以摊还时间是O（logN）。



# 伸展树分析

当一项X作为一片树叶插入时，称为展开的一系列树的旋转使得X成为树的新的根。这是伸展树的主要操作，插入，删除都需要依靠展开来进行。



# 斜堆的摊还分析

有定义：一个节点p如果其右子树的后裔数至少是该p的后裔总数的一半，则称节点p是重的，否则称之为轻的。（一个节点的后裔个数包括其本身）即重节点就是 斜堆的位势函数。

## 合并操作

由于合并两个斜堆时只对两个斜堆的右子树进行合并，所以对两个斜堆的右子树进行标记即可。记H1和H2为两个堆，H1的右路径有l1个轻节点，h1个重节点， H2的右路径有l2个轻节点 ，h2个重节点。合并的时间花费是右路径节点总数：l1+l2+h1+h2.

### 重节点的改变数

由于斜堆合并时右路径都会交换子节点，所以重节点一定会变成轻节点，而轻节点不一定会变成重节点。所以重节点的净变化最多是l1+l2-h1-h2.（即位势变化） 与时间相加：2（l1+l2）。即斜堆的摊还界。由于l1和l2是原右路径上轻节点的个数，而一个轻节点的右子树小于以该节点为根的树的大小的一半，所以知道 l1+l2<=logN1+logN2,这就是O(logN).
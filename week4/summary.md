# 第6章  优先队列（堆）

优先队列ADT的有效实现

优先队列的使用

 优先队列的高级实现

父亲更大为大根堆，父亲更小为小根堆

## 6.1模型

Insert操作相当于Enqueue(入队)

DeleteMin操作相当于Dequeue（出队）

## 6.2一些简单的实现

方法1：在表头插入O（1）并遍历该链表以删除最小元O（n）。

方法2：始终让表处于排序状态，这使得插入代价昂贵O(n)二DeleteMin花费低廉O(1)。 

方法3:  二叉查找树,两种操作的平均运行时间均为O（log N），树高log N

二叉堆 

## 6.3二叉堆

 堆有两个性质，即结构性和堆序性

对堆的一次操作可能破坏这两个性质中的一个

#### 6.3.1  结构性质

堆是一棵被完全填满的二叉树，底层元素从左到右填入。这样的树被称为完全二叉树

若父节点编号为x,则子节点的编号分别为2x和2x+1

不需要指针，且遍历该树所需操作简单

唯一问题在于所需堆的大小需要事先估计

#### 6.3.2  堆序性质

使操作快速执行的性质是堆序性

堆序性：任何父节点都小于他的子节点们 

最小元总是可以在根处找到，我们以常数时间完成附加运算FindMin 

#### 6.3.3  基本的堆操作

需要始终保持堆序性质

插入

1、创建下一个空位

2、和父节点比较大小，若父节点 比自己大，则将父节点移到当前的空位

3、将插入值放到当前空位中

删除最小值

1、奖空位的左右子节点中的较小者向上移

2、把最后的值放到最后的空位上

#### 6.3.4 其他的堆操作

DecreaseKey (降低关键字的值)

IncreaseKey (增加关键字的值)

Delete (删除)

BuildHeap （构建堆）

###### /*定理6.1  包含2的h+1次方-1个节点、高为h的理想二叉树的节点高度和为2的h+1次方-1-（h+1）*/

## 6.4  优先队列的应用

#### 6.4.1  选择问题

在k=N/2时找出k个最大值的特殊算法

算法6A

将N个元素读入一个数组对该数组应用BulidHeap算法

然后执行k次DeleteMin操作，该堆中最后提取的就是第k个最大元素

算法6B

任意时刻一直维持k个最大元素集合S，并持续读入新元素与第k个元素进行比较，删去较小项。

此时会产生新的第k个最大元素，它可能是新增项也可能不是

在输入结束后，返回S中最小项

#### 6.4.2  事件模拟



## 6.5  d-堆

d-堆是二叉堆的简单推广，它恰像一个二叉堆，只是所有的节点都有d个儿子（因此，二叉堆是2-堆）

d-堆将Insert操作的运行时间改进为O（logd N）

对于大的d,DeleteMin花费比较时间，操作用时提高到O（d logdN）

如果d是常数，那么两种操作的运行时间都是O（log N）



## 6.6  左式堆

#### 6.6.1  左式堆的性质

左式堆与二叉堆的区别：左式堆趋于非常不平衡的

零路径长npl

性质：对于任意节点npl(leftchild)大于等于npl(rightchild)

偏重于使树向左增加深度

/*定理：在右路径上有r个节点的左式树必然至少有2的r次方-1个节点*/

由此可得N个节点的左式树有一条右路径最多含有log(N+1)个节点

#### 6.6.2  左式堆的操作

操作思路：工作放在右路径上进行，保证路径不会太深

insert和merge可能会破坏左式堆的性质

除数据、左指针、右指针所用空间外，每个单元还要有一个指示零路径长的项

可以通过把待插入项看成单节点堆并执行一次Merge来完成插入。

DeleteMin只要除掉根而得到两个堆，然后再将这两个队合并。

/*DeleteMin可以写成宏，调用DeleteMin1 和FindMin*/





## 6.7  斜堆

斜堆（skew heap）是左式堆的自调节形式。

斜堆是具有堆序性的二叉树，但是不存在对树的结构限制。

 

## 6.8  二项队列

左式堆和斜堆每次操作花费时间O（log N）时间，有效地支持了合并、插入和DeleteMin

#### 6.8.1  二项队列结构

二项队列（binomial queue）是指具有堆序的若干树的合集

树的集合称为森林

每一棵树都要求是二项树

高度为k的二项树Bk是通过将一棵二项树Bk-1附接到另一棵Bk-1的根上而构成，恰好有2的k次方个节点

#### 6.8.2  二项队列操作

##### 找到最小元

最多有log N棵不同的树，因此最小元可以以O（log N）时间找到

##### 二项队列的合并

高度相同的树合并

由于最小元需要放在根的位置，故将根元素大的二项树作为根元素小的二项树的子树

##### 时间分析

合并两棵二项树均花费常数时间，而总共存放O（log N）棵二项树

因此合并最坏情形下花费时间为O（log N）

##### 插入

插入即特殊的合并

##### deleteMin

令该树为Bk，原始优先队列为H

我们从H对应的二项森林中除去二项树Bk，形成新的二项树队列H1

除去Bk的根，得到一些二项树B0，B1,....Bk-1，共同形成H2

合并H1和H2，操作结束

操作花费O（log N） 

#### 6.8.3  二项队列的实现

deleteMin 要求每个结点的儿子都在一个链表中，而且每个节点都有一个指向它的第一个儿子的指针

还要求诸儿子按照它们的子树的大小排序

总之二项树的每个节点包含数据、第一个儿子以及右兄弟，二项树的儿子以递减次序排列
